# <%= package.name %>

> <%= package.description %>

<p>Hello friend. Have you ever had the need to:</p>

<ul>
  <li>...query a set of React Children by type or otherwise?</li>
  <li>...reject and remove some of your children for whatever [judgement free] reason?</li>
  <li>...ensure that your children return content at some level?</li>
</ul>

<p>If you answered yes to any of those questions, then it sounds like your children could use a nanny to help bring order to the chaos...</p>

<p><b>Version:</b> <%= package.version %></p>

<h2>Installation</h2>

```
$ npm install <%= package.name %> --save
```
<%- generateSummaryTable(utils) %>

<h2>What can I use to derive types for a comparison?</h2>
<p>You can use an imported type, a <code>React.ReactNode</code>, value from <code>typeOfComponent</code>, a string type for an HTML (JSX Intrinsic) element, or a string representation of the type by using the <code>customTypeKey</code> feature.</p>

<h3>Imported Type</h3>

```
import { getChildByType } from 'react-nanny';
import MyComponent from './MyComponent';

getChildByType(children, [MyComponent]);
```

<h3>React.ReactNode</h3>

```
import { getChildByType, removeChildrenByType } from 'react-nanny';
import MyComponent from './MyComponent';

const child = getChildByType(children, [MyComponent]);
...
removeChildrenByType(children, [child]);
```

<h3>typeOfComponent</h3>

```
import { getChildByType, removeChildrenByType, typeOfComponent } from 'react-nanny';
import MyComponent from './MyComponent';

const child = getChildByType(children, [MyComponent]);
...
removeChildrenByType(children, [typeOfComponent(child)]);
```

<h3>String type for HTML (JSX Intrinsic) Elements</h3>

```
import { getChildByType } from 'react-nanny';

getChildByType(children, ['div']);
```

<h3>customTypeKey</h3>
<h4>What the heck is a customTypeKey?</h4>
<p>One simple way to be able to define and identify a type on a component and ensure that it is the same in development builds and production builds is to add a constant prop that contains the string type. Consider the following hypothetical component:</p>

```
import React from 'react';

const Hello = ({ __TYPE }) => <div>Hello World!</div>;

Hello.defaultProps = {
  __TYPE: 'Hello',
};
```

<p>The <code>Hello</code> has a prop <code>__TYPE</code> that has a value of <code>'Hello'</code>. We can query against this value and know that it's reliable regardless of environment.</p>
<p>The <code>customTypeKey</code> in <code>react-nanny</code> defines what the name of this prop is. In our example, <code>customTypeKey</code> would be <code>'__TYPE'</code> to query using this technique</p>

```
import { getChildByType } from 'react-nanny';

getChildByType(children, ['Hello']);
```

<p>Let's say you don't like <code>__TYPE</code> and what to use your own value such as: <code>CUSTOM</code>. You can accomplish this by providing the name for the <code>customTypeKey</code>:</p>

```
import { getChildByType } from 'react-nanny';

getChildByType(children, ['Hello'], { customTypeKey: 'CUSTOM' });
```

For more information on how to enforce the integrity of the <code>customTypeKey</code>, check out my Medium article: <a href="https://mparavano.medium.com/find-filter-react-children-by-type-d9799fb78292" target="_blank">Find & Filter React Children By Type</a>

<p><em>Now, without further ado, the utils...</em><hr /></p>

<% for(var f=0; f < utils.length; f++) { %>
  <%- generateTable(utils[f], package.name) %>

<hr />
<% } %>

<a href="#package-contents"></a>
<h2>Package Contents</h2>

Within the module you'll find the following directories and files:

```html
package.json
CHANGELOG.md -- history of changes to the module
README.md -- this file
/<%= fileTree.name -%><% fileTree.children.forEach( function(child){ if (child.type == 'directory') { %>
  └───/<%= child.name -%><% child.children.forEach(function(grandChild){ if (grandChild.type == 'directory') { %>
    └───/<%= grandChild.name -%><% grandChild.children.forEach(function(greatGrand){ %>
      └───<%= greatGrand.name -%> - <%= formatBytes(greatGrand.size) -%><% }) } else { %>
      └───<%= grandChild.name -%> - <%= formatBytes(grandChild.size) -%><% } })} else { %>
  └───<%= child.name -%> - <%= formatBytes(child.size) -%><% }}) %>
```

<a href="#license"></a>
<h2>License</h2>

<%= package.license %>

<% if (package.author) { %>
<a href="#author"></a>
<h2>Author</h2>
<% if (package.author.name) { %><%= package.author.name %> [<%= package.author.email %>](<%= package.author.email %>)<% } else { %><%= package.author %><% } %>
<% } %>

<% if (package.contributors) { %>
<a href="#contributors"></a>
<h2>Contributors</h2>

<% package.contributors.forEach(function(contributor) { %>
  <%= contributor %>
<% }) %>
<% } %>

<a href="#dependencies"></a>
<h2>Dependencies</h2>

<% const dependencies = package.dependencies ? Object.getOwnPropertyNames(package.dependencies) : []; %>
<% if (dependencies && dependencies.length > 0) { %>
<table>
<% dependencies.forEach(function(dependency) { %>
  <tr>
    <td>
      <%= dependency %>
    </td>
    <td>
      <%= package.dependencies[dependency] %>
    </td>
  </tr>
<% }) %>
</table>
<% } else { %>
None
<% } %>